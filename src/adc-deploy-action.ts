/*
 * Copyright 2024 The Backstage Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { AuthService, resolveSafeChildPath } from '@backstage/backend-plugin-api';
import { CatalogApi } from '@backstage/catalog-client';
import { createTemplateAction } from '@backstage/plugin-scaffolder-node';
import { z } from 'zod';
import { Entity, entitySchemaValidator, stringifyEntityRef } from '@backstage/catalog-model';
import { ADCEntityProviderService } from './adc-entity-provider-service';
import { ADCDeploymentInfo, ADCLocationURL } from '.';
import { createCatalogWriteAction } from '@backstage/plugin-scaffolder-backend';


export const adcDeployAction = (adcEntityProvider: ADCEntityProviderService, catalogApi: CatalogApi, authService: AuthService) => {

  return createTemplateAction({
    id: 'gcloud:adc:deploy',
    description: 'Deploy an adc application template.',
    schema: {
      input: z.object({
        adcTemplate: z.string().describe('The ADC application template identifier to deploy.'),
        adcToken: z.string().describe('Google OAuth token with necessary IAM permissions to deploy on Google Cloud ADC.'),
        entity: z.record(z.any()).describe('Entity schema values for the ADC entity.'),
        writeCatalogInfoFile: z.boolean().describe('If catalog-info.yaml file should be written in the workspace for usage by a next step of the template execution. In case false it will try to register the ADC entity using the ADC custom entity provider if available. Default: false').default(false)
      }).required(),
      output: z.object({
        resourceUrl: z.string().describe('Google Cloud resource URL generated by the ADC template deployment.'),
        catalogInfoFilePath: z.string().describe('The filepath of the generated catalog-info.yaml file for the ADC deployed entity.').optional(),
        entityRef: z.string().describe('The registered entity ref in the catalog.').optional()
      })
    },
    async handler(context) {

      async function withDeploymentRollbackOnFailure(actionFunction: Function) {
        try {
          return await actionFunction();
        } catch (error) {
          context.logger.error(`An error ocurred while completing step action: ${error}`);
          context.logger.info("Rolling back deployment...");
    
          let rollbackSucceeded = false;
          
          while(!rollbackSucceeded) {
            // Call to ADC delete deployment endpoint
            // const rollbackResponse = await fetch('https://adc.google.cloud/deploy', {
            //   method: 'POST',
            //   headers: {
            //     'Content-Type': 'application/json',
            //     'Authorization': `Bearer ${context.input.token}`,
            //   },
            //   body: JSON.stringify({ templateId: context.input.adcTemplate }),
            // });
            const rollbackResponse = (await new Promise<{ ok: boolean, statusText: string }>((resolve, _) => {
              setTimeout(() => resolve(({
                ok: true, 
                statusText: '200 OK',
              })), 1500);
            }));
            if (rollbackResponse.ok) {
              rollbackSucceeded = true;
            }
          }
    
          throw Error('An error occured while completing step action. ADC template deployment was rolled back.') 
        }
      }

      context.logger.info("Validating entity schema values...")

      const validateEntity = entitySchemaValidator();
      
      let entity: Entity;
      
      try {
        entity = validateEntity(context.input.entity);
      } catch(errors) {
        throw Error(`Validation for provided entity failed: ${errors}`);
      }

      entity = {
        ...entity,
        metadata: {
          ...entity.metadata,
          annotations: {
            ...entity.metadata.annotations,
            'backstage.io/source-template': context.templateInfo?.entityRef as string
          }
        }
      }

      const adcDeploymentInfo: ADCDeploymentInfo = {
        adcTemplate: context.input.adcTemplate,
        adcDeploymentCallUrl: `${ADCLocationURL}deploy:${context.input.adcTemplate}`,
        resourceUrl: '',
      }

      context.logger.info('Searching entity in software catalog...');

      const registeredEntity = await catalogApi.getEntityByRef({
        kind: entity.kind,
        name: entity.metadata.name,
        namespace: entity.metadata.namespace || 'default',
      });

      if (registeredEntity) {
        throw Error(`Entity for ref: ${stringifyEntityRef(registeredEntity)} already exists.`);
      }
      
      context.logger.info('Starting deployment on ADC...');
      context.logger.info('Deployment info: ');
      context.logger.info(`ADC template: ${context.input.adcTemplate}`);

      // Call to ADC Deploy endpoint
      // const response = await fetch('https://adc.google.cloud/deploy', {
      //   method: 'POST',
      //   headers: {
      //     'Content-Type': 'application/json',
      //     'Authorization': `Bearer ${context.input.token}`,
      //   },
      //   body: JSON.stringify({ templateId: context.input.adcTemplate }),
      // });

      const response = (await new Promise<{ok: boolean, statusText: string, body: {resourceUrl: string}}>((resolve, _) => {
        setTimeout(() => resolve(({
          ok: true, 
          statusText: '200 OK',
          body: {
            resourceUrl: 'https://vpc1238121.google.cloud:2873'
          }
        })), 1500);
      }));
      
      if (!response.ok) {
        throw new Error(`Deployment failed: ${response.statusText}`);
      }

      adcDeploymentInfo.resourceUrl = response.body.resourceUrl;

      context.logger.info('Deployment succeeded.');

      if (context.input.writeCatalogInfoFile) {

          return await withDeploymentRollbackOnFailure(async () => {
            entity = adcEntityProvider.generateADCEntityConfiguration(entity, adcDeploymentInfo, false)
    
            const catalogWriteAction = createCatalogWriteAction();
            await catalogWriteAction.handler({ 
              ...context,
              input: {
                entity,
              } 
            });
    
            context.logger.info('catalog-info.yaml file write succeeded.');
    
            const catalogInfoFilePath = resolveSafeChildPath(context.workspacePath, 'catalog-info.yaml');
            context.logger.info(`catalogInfoFilePath: ${catalogInfoFilePath}`)
    
            context.output('resourceUrl', adcDeploymentInfo.resourceUrl);
            context.output('catalogInfoFilePath', catalogInfoFilePath);
  
        });
      }
      
      return await withDeploymentRollbackOnFailure(async () => {
        context.logger.info('Registering entity into the Software Catalog...');
        const entityRef = stringifyEntityRef(await adcEntityProvider.registerADCEntity(entity, adcDeploymentInfo));
  
        context.logger.info('Entity registration succeeded.');
        context.logger.info(`entityRef: ${entityRef}`)
  
        context.output('resourceUrl', adcDeploymentInfo.resourceUrl);
        context.output("entityRef", entityRef);
      })

    }
  });
};